# Guide de Test du Proxy Reverse - Étapes Détaillées

## Prérequis
Avant de commencer les tests, assurez-vous que :
1. Les backends Python sont démarrés sur les ports 8081, 8082, 8083
2. Le proxy est compilé (`make`)
3. Les fichiers de configuration existent (config/backends.cfg, config/cache_rules.cfg)

## Commandes pour démarrer les composants

### Démarrer les backends Python
```bash
# Terminal 1
python3 -m http.server 8081

# Terminal 2
python3 -m http.server 8082

# Terminal 3
python3 -m http.server 8083
```

### Démarrer le proxy
```bash
# Terminal 4
./proxy -p 8085 round-robin
```

## Tests Fonctionnalité par Fonctionnalité

### 1. Test de Démarrage du Proxy
**Objectif**: Vérifier que le proxy démarre correctement et charge la configuration

**Commandes**:
```bash
# Vérifier que le proxy écoute sur le port 8085
netstat -tlnp | grep 8085

# Vérifier les logs de démarrage
tail -20 proxy.log
```

**Résultat attendu**:
- Port 8085 en écoute
- Logs montrant le chargement des backends et règles de cache
- Message "Proxy server ready. Press Ctrl+C to stop."

### 2. Test de Service de Fichiers Statiques
**Objectif**: Vérifier que le proxy sert correctement les fichiers HTML locaux

**Commandes**:
```bash
# Tester la page d'accueil
curl -v http://localhost:8085/

# Vérifier le contenu
curl http://localhost:8085/ | head -10

# Tester une autre page
curl http://localhost:8085/page1.html
```

**Résultat attendu**:
- Code HTTP 200
- Content-Type: text/html
- Contenu HTML affiché
- Taille correcte (847 octets pour index.html)

### 3. Test d'Exécution PHP
**Objectif**: Vérifier que les scripts PHP sont exécutés localement

**Commandes**:
```bash
# Tester un script PHP
curl http://localhost:8085/index.php

# Tester un autre script PHP
curl http://localhost:8085/test.php
```

**Résultat attendu**:
- Code HTTP 200
- Contenu dynamique PHP
- Affichage de l'heure, IP client, backend actuel

### 4. Test de Load Balancing
**Objectif**: Vérifier la distribution des requêtes entre les backends

**Commandes**:
```bash
# Faire plusieurs requêtes vers une ressource inexistante (proxying)
for i in {1..10}; do
  curl -s http://localhost:8085/nonexistent 2>/dev/null | grep -o "127.0.0.1:808[0-9]" || echo "Backend $i"
done

# Vérifier les logs pour voir la sélection des backends
tail -50 proxy.log | grep "Selected backend"
```

**Résultat attendu**:
- Requêtes distribuées selon les poids (3:2:1)
- Alternance entre 8081, 8082, 8083
- Logs montrant "Selected backend: 127.0.0.1:808X"

### 5. Test de Proxying vers Backends
**Objectif**: Vérifier que les requêtes sont forwardées aux backends quand les fichiers locaux n'existent pas

**Commandes**:
```bash
# Tester une ressource inexistante
curl http://localhost:8085/test

# Tester avec verbose
curl -v http://localhost:8085/api/data
```

**Résultat attendu**:
- Réponse du serveur Python (404 ou contenu par défaut)
- Logs montrant "Forwarding to backend: 127.0.0.1:808X"

### 6. Test du Cache
**Objectif**: Vérifier que le cache fonctionne selon les règles configurées

**Commandes**:
```bash
# Faire une requête qui devrait être cachée
curl -s http://localhost:8085/test > /dev/null

# Vérifier les logs de cache
tail -20 proxy.log | grep -i cache

# Faire la même requête à nouveau
curl -s http://localhost:8085/test > /dev/null

# Vérifier si c'est un HIT
tail -10 proxy.log | grep -i "cache.*hit\|cache.*miss"
```

**Résultat attendu**:
- Première requête: CACHE MISS
- Deuxième requête: CACHE HIT (si dans la TTL)
- Logs montrant les règles de cache appliquées

### 7. Test des Health Checks
**Objectif**: Vérifier que les backends sont surveillés

**Commandes**:
```bash
# Laisser tourner quelques minutes
sleep 30

# Vérifier les logs de health check
tail -50 proxy.log | grep -i "health\|check\|backend.*healthy"

# Arrêter un backend et voir la réaction
# (Dans un autre terminal)
pkill -f "python3 -m http.server 8081"

# Attendre et vérifier
sleep 15
tail -20 proxy.log | grep -i "health\|unhealthy"
```

**Résultat attendu**:
- Logs réguliers de vérification des backends
- Backend marqué comme unhealthy quand arrêté

### 8. Test de Sécurité - Rate Limiting
**Objectif**: Vérifier la limitation du taux de requêtes

**Commandes**:
```bash
# Faire beaucoup de requêtes rapidement
for i in {1..50}; do
  curl -s http://localhost:8085/ > /dev/null &
done

# Vérifier les logs
tail -50 proxy.log | grep -i "rate limit\|too many"
```

**Résultat attendu**:
- Certaines requêtes rejetées avec 429 Too Many Requests
- Logs montrant "Rate limit exceeded"

### 9. Test de Sécurité - Blacklist
**Objectif**: Vérifier le blocage des IPs blacklistées

**Commandes**:
```bash
# Ajouter une IP à la blacklist
echo "127.0.0.1" >> config/blacklist.txt

# Redémarrer le proxy
pkill -f "./proxy"
./proxy -p 8085 round-robin &

# Tester
curl http://localhost:8085/
```

**Résultat attendu**:
- Réponse 403 Forbidden
- Log "Blacklisted IP: 127.0.0.1"

## Tests sur Client/Serveur

### Configuration Client
Pour tester depuis un autre client :
1. Assurez-vous que le serveur proxy est accessible (port 8085 ouvert)
2. Utilisez un navigateur web ou curl depuis une autre machine
3. Testez les URLs :
   - http://[IP_SERVEUR]:8085/ (page d'accueil)
   - http://[IP_SERVEUR]:8085/index.php (PHP)
   - http://[IP_SERVEUR]:8085/nonexistent (proxying)

### Tests de Performance
```bash
# Test de charge avec ab (Apache Benchmark)
ab -n 1000 -c 10 http://localhost:8085/

# Test avec siege
siege -c 10 -t 30s http://localhost:8085/
```

### Monitoring Continu
```bash
# Surveiller les logs en temps réel
tail -f proxy.log

# Compter les requêtes par backend
tail -f proxy.log | grep "Selected backend" | cut -d: -f2 | sort | uniq -c
```

## Dépannage

### Si le proxy ne démarre pas
- Vérifier que les ports 8081-8083 sont libres
- Vérifier les fichiers de configuration
- Consulter proxy.log pour les erreurs

### Si les backends ne répondent pas
- Vérifier que les serveurs Python tournent
- Tester directement : curl http://localhost:8081/

### Si le cache ne fonctionne pas
- Vérifier config/cache_rules.cfg
- Logs doivent montrer "Cache MISS/HIT"

### Redémarrage Complet
```bash
# Arrêter tout
pkill -f "./proxy"
pkill -f "python3 -m http.server"

# Redémarrer
python3 -m http.server 8081 &
python3 -m http.server 8082 &
python3 -m http.server 8083 &
./proxy -p 8085 round-robin &
```

## Métriques à Surveiller
- Temps de réponse des requêtes
- Distribution des requêtes entre backends
- Taux de HIT/MISS du cache
- Nombre de rejets rate limiting
- Statut des backends (healthy/unhealthy)